% multiple1902 <multiple1902@gmail.com>
% appendice.tex
% Copyright 2011~2012, multiple1902 (Weisi Dai)
% https://code.google.com/p/xjtuthesis/
% 
% It is strongly recommended that you read documentations located at
%   http://code.google.com/p/xjtuthesis/wiki/Landing?tm=6
% in advance of your compilation if you have not read them before.
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
% 
% The Current Maintainer of this work is Weisi Dai.
%
\xjtuappendixchapter{文章翻译：Networking Named Content选段}

\xjtuappendixsection{外文文献介绍及地址}
\par
本文翻译的文章是Van Jacobson et al.的提出命名数据网概念的第一篇文章，Networking named content。也是本文的主要参考文献。出于篇幅的限制，本文在此并不直接给出外文原文。外文原文可以在2009年Sigcomm Conference找到\footnote{外文原文的链接之一，http://conferences.sigcomm.org/co-next/2009/papers/Jacobson.pdf}。由于原文篇幅较长，而在第5部分之后所叙述的内容和本文的研究关联度较低，本文仅对该文前面的几个部分作出完整翻译。
\xjtuappendixsection{中文译文}
\subsection*{摘要}
\par
现今，网络使用已由数据发布与请求所主宰，而网络通信仍是基于多个端点的地址。用户的数据及服务请求需要经过所请求数据到数据所在地址的映射。本文提出以内容为中心的网络架构(Content Centric Networking, CCN)，将数据，而不是地址，作为网络架构的基本单元，并把数据和地址、安全及访问区分开来，同时以数据的名称来请求对应的数据。
\par
\subsection*{简介}
当今网络的架构和设计原则继承着60年代、70年代的思路，当时所希望解决的主要问题是资源共享，即由多个终端远程访问共享的昂贵资源，比如读卡器或是高速磁带硬盘。由此开发出的通信模型可以抽象为两点之间的信息交互：服务请求方希望使用服务提供方的特定服务。因而IP报文中包含两个标示符，目的地址和源地址。而网络中的几乎所有流量(大多是基于TCP协议的会话)，都是数对请求方、提供方之间的通信。
\par
基于数据报交互的网络架构形成的50年来，计算机及其附件变得便宜和大众化。网络所提供的方便的互联性和低存储成本使得2008年一年就发布了500EB的数据。大众对网络价值的衡量变得倾向于其所提供的数据本身，而不是数据具体存储在哪里。
\par
这两种模型之间的差异在以下几个方面影响到了用户。
\begin{itemize}
\item
可用性：高速、可靠的数据访问需要利用不自然的、预先计划好的，且不同应用之间难以共享的解决方案，例如CDN和点对点网络。这些解决方案同时消耗了多余的带宽资源。
\item
安全：基于来源位置和连接信息的安全模型容易混淆对数据本身的信任。
\item
地点有关性：将数据映射到所在位置使得配置和实现网络服务更加复杂。
\end{itemize}
\par
直接、统一的解决这些问题的方案是用“什么”取代“哪里“。端对端通信模型仅适用于60年代的用例。本文认为，基于数据名称而不是位置的命名数据网将是能够更好描述当今网络用户需求的网络架构模型。CCN底层并没有“端”或地址的概念，取而代之的数据的名称。然而，其设计仍然保留TCP/IP协议栈简单、鲁棒和可扩展的设计原则。
\par
图1\footnote{翻译中不再拷贝原文的图片，请直接按照原文图片编号进行参考}对比CCN和IP协议栈。协议栈中大多数层体现了两者之间的相似性，比如第二层的成帧协议体现了物理链路中发送方、接收方之间的协商，第四层传输层协议体现了数据或服务的请求者、提供者之间的协商。承上启下，为双方提供统一接口的第3层，即网络层，体现了IP协议成功的许多因素。首先，网络层对链路层提供的服务的需求很少，无状态、不可靠、不保序、尽力而为即可。CCN的网络层(即第三层)，在这一点上和IP是吻合的，即不对链路层提供的服务提出过高要求。这一点为其保留了IP较多优点。同时值得一提的是，CCN也可以作为多层的负载，包括作为IP的负载。
\par
CCN在许多关键点上不同于IP。其中两者是策略和安全。两者作为其协议栈中新出现的层。CCN可以最大化利用同时存在的多个连接，比如以太网、3G、蓝牙和802.11，因为CCN和第二层的关系更加简单。策略层在变化的外界条件下，根据多个同时存在的连接，做出详细的、动态的优化，从而最大化的利用多个连接。安全层保障数据本身是受信任的，而不是数据所经过的通路是受信任的，由此避免了安全策略上IP网络的许多问题。
\par
本文的2~5章将描述CCN的架构和流程；第6章基于我们的初步实现，对其进行评估；第7、8章讨论未来的工作方向并总结。
\par
\subsection*{CCN节点模型}
CCN网络通信是由数据请求方驱使的。网络中有两种包，数据请求(Interest)和数据应答(Data)。数据请求方向本地的所有连接广播数据请求，任何收到数据请求，并且有名称满足要求的数据的节点可以应答。数据应答包的发出都是由收到特定的请求所触发，换言之，数据应答包都是为了满足特定的请求。由于请求包、应答包都是通过名称索引的，多个请求同样名称的节点收到的应答包可以在广播媒介上用传统的多播压缩手段共享[3]\footnote{翻译中不再拷贝原文的参考文献，参考原文的参考文献编号}。
\par
当且仅当数据请求包的名称是数据应答包的名称的前缀子串时，数据应答可以满足数据请求。CCN名称是由多个部分组成的透明的二进制对象(见图4)。传统意义上的名称都是层次结构的，所以前缀的吻合可以描述为数据应答包的名称是数据请求包的名称的子树(见3.2)。IP用同样的方式来解析树状的IP地址，即<网络地址，子网地址，主机地址>。IP的经验表明，这样的方式可以实现路由表树型的高效压缩和快速查找。这种匹配方式中其中值得一提的一点是节点可能收到对于尚不存在于网络中的数据的请求，这使得数据的提供方可以利用数据请求方指定的名称产生并发布数据。这样的“动态名称”使得CCN透明的支持动态生成的数据和静态缓存的数据，这两者在当今网络中扮演了重要角色。名称前缀也可能是上下文相关的，比如”/ThisRoom/Projector”可以用来和局部环境中存在的投影仪进行交互。而”/Local/Friends”可以和局部环境中的朋友进行交互。
\par
CCN节点的工作方式和IP节点是类似的：节点收到数据包，进行最长前缀匹配，并由匹配结果决定下一步行动。图3是CCN前递逻辑的结构图。其中主要有三个数据结构：前递表(Forwarding Information Base)，数据缓存(Content Store)和待应答表(Pending Interest Table)。
\par
前递表的作用是将数据请求传递向可能有对应的数据应答的节点。这与IP的路由表是相近的，但是它允许一个表项和多个接口进行匹配，而不是对于每一个接口，存在一张路由表。这一点体现了CCN不局限于基于一颗生成树的前递，其允许一个节点同时对多个连接的数据源进行请求，多个数据源也可以同时处理收到的请求。
\par
数据缓存和IP路由的缓存作用近似，但是替换策略不同。由于每个IP包包含了源和目的地址，其对于别的点之间的交互是不起到作用的。因此，IP路由器在将收到的包写入缓存，然后转发出去之后，就可以将该包擦除(利用最近使用(MRU)替换)。CCN包是幂等，自识别和自授权的，因而每一个包有可能可以满足多个用户的数据请求(比如多个看同样的报纸和Youtube视频的用户)，只要数据请求的名称匹配。为了最大化数据共享的可能性，从而最小化上行带宽的占用和下行的延迟，CCN尽可能长时间的缓存数据包(利用最近/最少未使用替换)。
\par
待应答表保存了向数据提供方前递的数据请求(上行请求)，因此当收到数据提供方的应答时，可以根据待应答表中的记录将数据应答传送给数据请求方。因此，在CCN中，只有数据请求包在上行时经过路由，并在经过路由节点的同时留下一系列的记录，下行的数据应答包可以根据路由节点的记录找到数据的请求者。在路由节点收到下行数据应答后，其将所收数据应答对待应答表中的对应表项中的所有节点进行多播，并且擦除该表项。长时间没有收到数据应答的数据请求会超时，而如果数据请求方仍然希望请求该数据，请求方应当负责重新发送数据请求。
\par
当数据请求包到达某节点的某接口后，节点首先进行名称的最长前缀匹配。上述数据结构的查找是有序的，所以数据缓存的匹配优先级高于待应答表，高于前递表。
\par
因此，在一个节点收到请求后，如果数据缓存找到了满足请求的数据，会直接返回该数据，同时收到的请求由于已经被满足而会被丢弃。
\par
如果数据缓存没有前缀匹配项，而待应答表中有名称完全匹配项，收到请求的接口会被加入到路由节点待应答表中该名称的下行接口表上，同时收到的请求会由于别人已经在请求同名数据，且别人的请求已经向数据源上行而被丢弃。这时路由节点所要做的只是当数据应答到来时，将数据应答也向这个数据请求的接口发送一份。
\par
如果二者都没有匹配项，而前递表有匹配项，则数据请求根据前递表的匹配项上行。收到请求的接口将会被从前递表匹配项上移除，如果前递表匹配项此时仍不为空，则对于其所记录的每一个接口发送该数据请求。并以收到请求的接口，创建一个新的待应答表项。
\par
如果三者都没有匹配的表项，则丢弃该数据请求，因为收到请求的路由节点既没有满足要求的数据，也不知道该向哪里前递已获取满足要求的数据。
\par
数据应答包的处理要相对简单。由于数据应答包不经过路由，而是直接根据待应答表进行下行，在收到数据应答时，首先进行名称的最长前缀匹配。如果数据缓存有匹配项，则收到了重复的数据，予以丢弃。如果前递表发现了满足项，则说明待应答表中没有满足项，说明数据没有请求者，是不需要的，予以丢弃。如果带应答表中发现满足项，则(可选的)进行数据核实和写入数据缓存，之后根据待应答表的满足项移除收到数据应答的接口后，对满足项中的其它接口进行下行。
不同于IP先入先出的缓存模型，CCN缓存模型允许整个网络的节点缓存实现透明缓存。所有节点可以根据自己的能力和策略进行缓存。
\par
通过数据请求指定的多点数据回取的特点使得CCN在变化快速的环境下依然可以灵活应用。任何处在多个网络中的节点可以作为其所处的多个网络之间的缓存和路由。利用其缓存，一个移动的节点可以作为多个彼此不相连区域进行连接的媒介，或者为不连贯的链路提供延迟的连接。因此，CCN的传输是允许干扰的(Disruption Tolerant Networking[11])。数据请求/应答的交互在仅有局域网连接时也可以正常工作，比如，两个处于同一自组织无线网的同事可以在二人没有公司局域网或广域网连接的情况下共享文件。
\subsection*{传输}
\par
CCN传输是基于不可靠的包交互设计的，其包括对高度动态的连接性的移动和普及计算。因此，数据请求、应答都可能在传输中丢包或是损坏，或者请求的数据会短时不可用。为了提供可靠的传输，一段时间内没有得到满足的CCN数据请求必须进行重传。不同于TCP，CCN发送方是无状态的。因而如果请求者依然希望得到数据，数据请求者需为重传请求负责。接收方策略层将为某一特定接口的数据请求重传进行负责(因为它会得到该接口上行数据请求超时的通知)，同时，接收方也应决定向多少、哪些可用的连接发送请求，允许多少未收到应答的请求存在，和不同数据请求之间的优先级等等。
\par
下层的数据包交互网络和CCN的多点交互可能会产生多个同样的数据包。根据上述逻辑，同样的数据应答包会被节点丢弃。虽然数据应答不会在CCN的结构中形成环路，数据请求是可能形成环路的，并且使其看起来像是有数据请求存在，实际没有数据请求存在。为了检测和避免数据请求的环路，数据请求应包含一个随机生成的随机数字段(nonce)，多个接口在收到相同随机数的数据请求时也可以丢弃对应的数据请求。
\par
CCN请求的流量控制和序号和TCPACK包是类似的，二者将在后面继续讨论。另外，一个节点必然可以看到其请求带回的应答，且反应时间和速度可以直接测量并用于决定对于某些前缀满足请求的最好方式的特性将在第3部分讨论。

\subsection*{可靠性和流量控制}
\par
一个数据请求最多可以带回一个数据应答。这项原则为网络维持请求、应答的平衡。从而使得连接速度不同的机器更有效的交互。这与TCP的设计是类似的，只是可以重叠数据应答和请求。多个数据请求可以同时发出，取回的数据应答将满足第一个请求。在此用例中请求起到的作用类似TCP的滑动窗口。收方可以通过调整其发出兴趣的多少，来实时的控制窗口的大小。如此的流水线式的设计造成的影响在6.2中讨论。由于每个CCN包是独立命名的，在出现丢包时流水线不会停顿，这一点与TCP SACK的固有性是一致的。
\par
在大型网络中，TCP会话端对端的性质意味着即使每个会话满足流量出入平衡，端对端之间的节点仍然会出现拥塞，由于多组会话可能都通过同一个中间节点。这样的拥塞导致的结果是延迟和丢包。对于此问题，TCP的解决方案是由断点实时设置其窗口大小，从而使得汇聚后的流量仍然低于拥塞出现的流量。这样的拥塞控制本质上是由TCP会话的端对端特性导致的。而在CCN中，不同的是每个点都满足数据请求、数据应答的出入平衡。因为CCN流量控制是每一跳都满足的出入平衡，所以不需要为了防止某一中间节点出现拥塞而另外设计方案。这一点和利用相邻节点的反馈来维持每一跳的流量平衡的方案是不同的。CCN中取代链路间的先入先出队列缓存的是最近最少未使用缓存，其可以起到解开每两跳间反馈控制的反馈环和欠阻尼震荡的作用。(这一点将在未来的论文中讨论)

\subsection*{排序}
\par
在端对端的TCP会话中，数据包是通过序号唯一识别的。CCN需要实现更复杂的策略，因为数据请求方可能会请求大块数据的某一特定部分，并且该部分将可能与多个别的请求者共享。数据的定位和共享数据通过部分上有实际意义，人可阅读的，树状名称实现，而不是通过某一当前会话中的序列号。尽管CCN名称显得丰富很多，它们对传输过程起到的作用和TCP ACK的序列号是相同的，即指定请求方需要请求的下一块数据。
\par
在阐述如何描述下一块数据前，我们先更详细的解释名称。如前面所提到的，名称是树状结构的，树中的每一个节点是名称中的一块。每一块由事先规定好的字节开始，名称本身对CCN的传输不起影响。名称需要体现上层协议的设计思路，从而对上层应用有意义。名称的传输除了要保留块结构外，并没有其它的要求。整型或是其它更复杂的数据类型可以直接使用其二进制编码进行传输，而不必转化为文本。出于隐私性的考虑，可以加密特定的名称块。为了表达方便，本文中名称的表示形式类似URI，如图4所示，用’/’来划分多个名称块。需要注意的是’/’本身并不是名称中的一部分，也不应出现在名称的二进制编码中。下面的例子介绍了应用层当前采用的命名大块数据的方式(利用一个版本标示符，\_v，编码为FD，加上一个整型的版本号；和一个分块标示符，\_a，编码为00，加上一个整型的块编号。这样的块编号的含义可以是大块数据中某一部分的帧编号；某一特定的字节编号；或是视频传输中的某一帧的序号)。每个数据应答包名称的最后一个部分隐式包含了该包的SHA256哈希值。数据请求包可以准确指定需求的哪一块数据，但是在很多用例中下一块数据的全名是不清楚的。请求者可以在名称中通过指定下一块数据和上一块在名称上的关系，来请求下一块数据。这一点的原因是CCN名称树是完全有序的，同一父节点的子节点按照字典序排列，前一或者后一这样的关系可以被完全不了解名称语义的中间节点无二意的理解。
\par
例如，图5是图4种名称树的一部分。一个需要显示最新一帧画面的应用可以通过发出/parc.com/videos/WidgetA.mpg RightMostChild的数据请求来完成图中高亮的遍历方式，从而取回该视频中第一块的第二版。在取回这一块后，下一块的取回可以通过“本块最左的右兄”名称标示符，或是根据应用设计的名称空间，计算出名称\_s1。
\par
如此例中所示，数据命名的分块是为了利用名称树的依据相对关系遍历的特点。尽管命名规则本身不是CCN传输的一部分，它们却是应用开发中最为重要的。我们希望开发出一系列的可重用的命名空间开发规范，并在共享的函数库中进行实现和标准化，从而为应用开发者抽象出更高层的库支持，例如基于CCN的文件传输，视频流传输等。
\par
综上，数据请求包提供了整个CCN网络由标示符限制的查询功能，该功能使得请求者可以方便的制定下一块请求的数据。在此受到篇幅限制，我们对当前设计的标示符不予讨论。在未来的实现中，不仅可以对应答方的资源做相对关系的限制，还将可以除去特定名称对应的名称子块。同时我们还在开发高层的名称发现策略，从而使得用户可以在大的名称树中不请求数据本身的情况下浏览名称树。
